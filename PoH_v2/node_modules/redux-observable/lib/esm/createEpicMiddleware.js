var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

import { Subject } from 'rxjs';
import { map, switchMap } from 'rxjs/operators';
import { ActionsObservable } from './ActionsObservable';
import { StateObservable } from './StateObservable';
import { EPIC_END } from './EPIC_END';

var defaultAdapter = {
  input: function input(action$) {
    return action$;
  },
  output: function output(action$) {
    return action$;
  }
};

var defaultOptions = {
  adapter: defaultAdapter
};

export function createEpicMiddleware(rootEpic) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;

  if (typeof rootEpic !== 'function') {
    throw new TypeError('You must provide a root Epic to createEpicMiddleware');
  }

  // even though we used default param, we need to merge the defaults
  // inside the options object as well in case they declare only some
  options = _extends({}, defaultOptions, options);

  var input$ = new Subject();
  var action$ = options.adapter.input(new ActionsObservable(input$));
  var epic$ = new Subject();
  var store = void 0;

  var epicMiddleware = function epicMiddleware(_store) {
    if (process.env.NODE_ENV !== 'production' && store) {
      // https://github.com/redux-observable/redux-observable/issues/389
      require('./utils/console').warn('this middleware is already associated with a store. createEpicMiddleware should be called for every store.\n\n See https://goo.gl/2GQ7Da');
    }
    var stateInput$ = new Subject();
    var state$ = new StateObservable(stateInput$, _store);
    store = _store;

    return function (next) {
      var result$ = epic$.pipe(map(function (epic) {
        var output$ = 'dependencies' in options ? epic(action$, state$, options.dependencies) : epic(action$, state$);

        if (!output$) {
          throw new TypeError('Your root Epic "' + (epic.name || '<anonymous>') + '" does not return a stream. Double check you\'re not missing a return statement!');
        }

        return output$;
      }), switchMap(function (output$) {
        return options.adapter.output(output$);
      }));

      result$.subscribe(store.dispatch);

      // Setup initial root epic. It's done this way so that
      // it's possible for them to call replaceEpic later
      epic$.next(rootEpic);

      return function (action) {
        // Downstream middleware gets the action first,
        // which includes their reducers, so state is
        // updated before epics receive the action
        var result = next(action);

        // It's important to update the state$ before we emit
        // the action because otherwise it would be stale!
        stateInput$.next(store.getState());
        input$.next(action);

        return result;
      };
    };
  };

  epicMiddleware.replaceEpic = function (rootEpic) {
    // gives the previous root Epic a last chance
    // to do some clean up
    store.dispatch({ type: EPIC_END });
    // switches to the new root Epic, synchronously terminating
    // the previous one
    epic$.next(rootEpic);
  };

  return epicMiddleware;
}