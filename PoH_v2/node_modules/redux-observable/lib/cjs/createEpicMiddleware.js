'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.createEpicMiddleware = createEpicMiddleware;

var _rxjs = require('rxjs');

var _operators = require('rxjs/operators');

var _ActionsObservable = require('./ActionsObservable');

var _StateObservable = require('./StateObservable');

var _EPIC_END = require('./EPIC_END');

var defaultAdapter = {
  input: function input(action$) {
    return action$;
  },
  output: function output(action$) {
    return action$;
  }
};

var defaultOptions = {
  adapter: defaultAdapter
};

function createEpicMiddleware(rootEpic) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;

  if (typeof rootEpic !== 'function') {
    throw new TypeError('You must provide a root Epic to createEpicMiddleware');
  }

  // even though we used default param, we need to merge the defaults
  // inside the options object as well in case they declare only some
  options = _extends({}, defaultOptions, options);

  var input$ = new _rxjs.Subject();
  var action$ = options.adapter.input(new _ActionsObservable.ActionsObservable(input$));
  var epic$ = new _rxjs.Subject();
  var store = void 0;

  var epicMiddleware = function epicMiddleware(_store) {
    if (process.env.NODE_ENV !== 'production' && store) {
      // https://github.com/redux-observable/redux-observable/issues/389
      require('./utils/console').warn('this middleware is already associated with a store. createEpicMiddleware should be called for every store.\n\n See https://goo.gl/2GQ7Da');
    }
    var stateInput$ = new _rxjs.Subject();
    var state$ = new _StateObservable.StateObservable(stateInput$, _store);
    store = _store;

    return function (next) {
      var result$ = epic$.pipe((0, _operators.map)(function (epic) {
        var output$ = 'dependencies' in options ? epic(action$, state$, options.dependencies) : epic(action$, state$);

        if (!output$) {
          throw new TypeError('Your root Epic "' + (epic.name || '<anonymous>') + '" does not return a stream. Double check you\'re not missing a return statement!');
        }

        return output$;
      }), (0, _operators.switchMap)(function (output$) {
        return options.adapter.output(output$);
      }));

      result$.subscribe(store.dispatch);

      // Setup initial root epic. It's done this way so that
      // it's possible for them to call replaceEpic later
      epic$.next(rootEpic);

      return function (action) {
        // Downstream middleware gets the action first,
        // which includes their reducers, so state is
        // updated before epics receive the action
        var result = next(action);

        // It's important to update the state$ before we emit
        // the action because otherwise it would be stale!
        stateInput$.next(store.getState());
        input$.next(action);

        return result;
      };
    };
  };

  epicMiddleware.replaceEpic = function (rootEpic) {
    // gives the previous root Epic a last chance
    // to do some clean up
    store.dispatch({ type: _EPIC_END.EPIC_END });
    // switches to the new root Epic, synchronously terminating
    // the previous one
    epic$.next(rootEpic);
  };

  return epicMiddleware;
}