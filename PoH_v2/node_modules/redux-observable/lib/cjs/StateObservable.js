'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StateObservable = exports.UNSET_STATE_VALUE = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _rxjs = require('rxjs');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Used as a placeholder value so we can tell
// whether or not the real state has been set,
// even if the real state was `undefined`
var UNSET_STATE_VALUE = exports.UNSET_STATE_VALUE = {};

// We can't use BehaviorSubject because when we create
// and give state$ to your epics your reducers have not
// yet run, so there is no initial state yet until the
// `@@redux/INIT` action is emitted. BehaviorSubject
// requires an initial value (which would be undefined)
// and if an epic subscribes to it on app boot it would
// synchronously emit that undefined value incorrectly.
// We also don't want to expose a Subject to the user at
// all because then they could do `state$.next()` and
// screw things up and it would just be a footgun.

var StateObservable = exports.StateObservable = function (_Observable) {
  _inherits(StateObservable, _Observable);

  function StateObservable(stateSubject, store) {
    _classCallCheck(this, StateObservable);

    var _this = _possibleConstructorReturn(this, (StateObservable.__proto__ || Object.getPrototypeOf(StateObservable)).call(this));

    _this.source = stateSubject;
    // If you're reading this, keep in mind that this is
    // NOT part of the public API and will be removed!
    _this.__store = store;
    _this.__value = UNSET_STATE_VALUE;

    _this.source.subscribe(function (value) {
      _this.__value = value;
    });
    return _this;
  }

  _createClass(StateObservable, [{
    key: '_subscribe',
    value: function _subscribe(subscriber) {
      var subscription = _get(StateObservable.prototype.__proto__ || Object.getPrototypeOf(StateObservable.prototype), '_subscribe', this).call(this, subscriber);
      if (this.__value !== UNSET_STATE_VALUE && subscription && !subscription.closed) {
        subscriber.next(this.__value);
      }
      return subscription;
    }
  }, {
    key: 'lift',
    value: function lift(operator) {
      var observable = new StateObservable(this);
      observable.operator = operator;
      return observable;
    }
  }, {
    key: 'getState',
    value: function getState() {
      if (process.env.NODE_ENV !== 'production') {
        require('./utils/console').deprecate('calling store.getState() in your Epics is deprecated and will be removed. The second argument to your Epic is now a stream of state$ (a StateObservable), instead of the store. To imperatively get the current state use state$.value instead of getState(). Alternatively, since it\'s now a stream you can compose and react to state changes.\n\n  function <T, R, S, D>(action$: ActionsObservable<T>, state$: StateObservable<S>, dependencies?: D): Observable<R>\n\nLearn more: https://redux-observable.js.org/MIGRATION.html');
      }
      return this.__value;
    }
  }, {
    key: 'dispatch',
    value: function dispatch() {
      var _store;

      if (process.env.NODE_ENV !== 'production') {
        require('./utils/console').deprecate('calling store.dispatch() directly in your Epics is deprecated and will be removed. The second argument to your Epic is now a stream of state$ (a StateObservable), instead of the store. Instead of calling store.dispatch() in your Epic, emit actions through the Observable your Epic returns.\n\n  function <T, R, S, D>(action$: ActionsObservable<T>, state$: StateObservable<S>, dependencies?: D): Observable<R>\n\nLearn more: https://redux-observable.js.org/MIGRATION.html');
      }
      return (_store = this.__store).dispatch.apply(_store, arguments);
    }
  }, {
    key: 'value',
    get: function get() {
      if (this.__value === UNSET_STATE_VALUE) {
        if (process.env.NODE_ENV !== 'production') {
          require('./utils/console').warn('You accessed state$.value inside one of your Epics, before your reducers have run for the first time, so there is no state yet. You\'ll need to wait until after the first action (@@redux/INIT) is dispatched or by using state$ as an Observable.');
        }
        return undefined;
      } else {
        return this.__value;
      }
    }
  }]);

  return StateObservable;
}(_rxjs.Observable);